from django.shortcuts import render, get_object_or_404
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.utils import timezone
from django.core.exceptions import ObjectDoesNotExist
from .models import (
    ServiceProvider,
)
from .serializer import (
    ServiceProviderSerializer,
)
from apps.Job.serializers import JobSerializer
from apps.Job.models import Job
from apps.User.models import User
from django.db import transaction
import logging

logger = logging.getLogger(__name__)


class ServiceProviderViewSet(viewsets.ModelViewSet):
    """
    ViewSet for viewing and editing ServiceProvider instances.
    """

    queryset = ServiceProvider.objects.all()
    serializer_class = ServiceProviderSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        queryset = super().get_queryset()

        # If user is not staff, only show their own provider profile
        if not self.request.user.is_staff:
            return queryset.filter(user=self.request.user)

        # For staff users, allow filtering by user_id
        user_id = self.request.query_params.get("user_id")
        if user_id:
            # Check if the user exists and is a provider
            try:
                user = User.objects.get(id=user_id)
                if user.user_type == "provider":
                    return queryset.filter(user=user)
                else:
                    # Return empty queryset if user is not a provider
                    return queryset.none()
            except ObjectDoesNotExist:
                # Return empty queryset if user doesn't exist
                return queryset.none()

        return queryset

    def list(self, request, *args, **kwargs):
        """
        Override list method to return single object when filtering by user_id
        """
        user_id = request.query_params.get("user_id")

        # If filtering by user_id, return single object instead of list
        if user_id:
            try:
                user = User.objects.get(id=user_id)
                if user.user_type == "provider":
                    provider = self.get_queryset().first()
                    if provider:
                        serializer = self.get_serializer(provider)
                        return Response(serializer.data)
                    else:
                        return Response(
                            {"detail": "Provider profile not found"},
                            status=status.HTTP_404_NOT_FOUND,
                        )
                else:
                    return Response(
                        {"detail": "User is not a service provider"},
                        status=status.HTTP_400_BAD_REQUEST,
                    )
            except ObjectDoesNotExist:
                return Response(
                    {"detail": "User not found"}, status=status.HTTP_404_NOT_FOUND
                )

        # Default list behavior for other cases
        return super().list(request, *args, **kwargs)

    @action(detail=True, methods=["post", "patch"])
    def activate(self, request, pk=None):
        provider = self.get_object()
        provider.status = "active"
        provider.save()
        return Response({"status": "provider activated"})

    @action(detail=True, methods=["post", "patch"])
    def suspend(self, request, pk=None):
        provider = self.get_object()
        provider.status = "suspended"
        provider.save()
        return Response({"status": "provider suspended"})

    @action(detail=True, methods=["post", "patch"])
    def verify(self, request, pk=None):
        provider = self.get_object()
        provider.verification_status = "verified"
        provider.last_verified = timezone.now()
        provider.save()
        return Response({"status": "provider verified"})

    @action(detail=False, methods=["get"])
    def get_provider_by_user_id(self, request):
        """Get provider by user id - only works when user type is provider"""
        user_id = request.query_params.get("user_id")

        if not user_id:
            return Response(
                {"detail": "user_id parameter is required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            # First check if the user exists and is a provider
            user = User.objects.get(id=user_id)

            if user.user_type != "provider":
                return Response(
                    {"detail": "User is not a service provider"},
                    status=status.HTTP_400_BAD_REQUEST,
                )

            # Get the provider profile
            provider = ServiceProvider.objects.get(user=user)
            serializer = ServiceProviderSerializer(provider)
            return Response(serializer.data)

        except ObjectDoesNotExist:
            return Response(
                {"detail": "User not found"}, status=status.HTTP_404_NOT_FOUND
            )
        except ObjectDoesNotExist:
            return Response(
                {"detail": "Provider profile not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

    @action(detail=False, methods=["get"])
    def accept_job(self, request):
        """Accept a job"""
        job_id = request.query_params.get("job_id")

        if not job_id:
            return Response(
                {"error": "job_id parameter is required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            job = Job.objects.get(id=job_id)
            job.accept_bid(request.user)
            return Response({"status": "Job accepted"})
        except ObjectDoesNotExist:
            return Response(
                {"error": "Job not found"}, status=status.HTTP_404_NOT_FOUND
            )

    @action(detail=False, methods=["get"])
    def activities(self, request):
        """Get provider activities and recent jobs"""
        try:
            # Get the provider for the current user
            provider = self.get_queryset().filter(user=request.user).first()

            if not provider:
                return Response(
                    {"detail": "Provider profile not found"},
                    status=status.HTTP_404_NOT_FOUND,
                )

            # Get recent jobs for this provider
            from apps.Job.models import Job

            recent_jobs = Job.objects.filter(assigned_provider=provider).order_by(
                "-created_at"
            )[:10]

            # Get job statistics
            total_jobs = Job.objects.filter(assigned_provider=provider).count()
            completed_jobs = Job.objects.filter(
                assigned_provider=provider, status="completed"
            ).count()
            active_jobs = Job.objects.filter(
                assigned_provider=provider, status__in=["assigned", "in_progress"]
            ).count()

            # Calculate completion rate
            completion_rate = (
                (completed_jobs / total_jobs * 100) if total_jobs > 0 else 0
            )

            return Response(
                {
                    "provider_info": {
                        "id": provider.id,
                        "business_name": provider.business_name,
                        "status": provider.status,
                        "verification_status": provider.verification_status,
                        "total_jobs": total_jobs,
                        "completed_jobs": completed_jobs,
                        "active_jobs": active_jobs,
                        "completion_rate": round(completion_rate, 2),
                    },
                    "recent_jobs": [
                        {
                            "id": job.id,
                            "title": job.title,
                            "status": job.status,
                            "created_at": job.created_at,
                            "estimated_duration": job.estimated_duration,
                            "total_amount": job.total_amount,
                        }
                        for job in recent_jobs
                    ],
                }
            )

        except Exception as e:
            logger.error(f"Error getting provider activities: {e}")
            return Response(
                {"detail": "Error retrieving provider activities"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

    @action(
        detail=False, methods=["post"], permission_classes=[permissions.IsAdminUser]
    )
    def sync_provider_users(self, request):
        """
        Sync users with user_type 'provider' to the ServiceProvider table.
        This will:
        1. Find all users with user_type 'provider'
        2. Create ServiceProvider entries for those who don't have one
        3. Return statistics about the sync operation
        """
        try:
            with transaction.atomic():
                # Get all users with user_type 'provider'
                provider_users = User.objects.filter(user_type="provider")

                stats = {
                    "total_provider_users": provider_users.count(),
                    "existing_entries": 0,
                    "new_entries": 0,
                    "errors": [],
                }

                for user in provider_users:
                    try:
                        # Check if ServiceProvider entry exists
                        from django.contrib.gis.geos import Point
                        
                        # Default location (London coordinates)
                        default_location = Point(-0.1276, 51.5074, srid=4326)
                        
                        # Truncate phone number to fit the 20-character limit
                        # Also handle cases where phone_number might be None or too long
                        phone_number = ""
                        if user.phone_number:
                            # Truncate to 20 characters for ServiceProvider.phone field
                            phone_number = str(user.phone_number)[:20]
                        else:
                            phone_number = "N/A"
                        
                        # Ensure business name fits within 200 character limit
                        business_name = f"{user.first_name}'s Service"
                        if len(business_name) > 200:
                            business_name = business_name[:197] + "..."
                        
                        # Create the defaults dictionary with all values
                        defaults_data = {
                            "business_type": "sole_trader",  # Default business type
                            "business_name": business_name,  # Truncated business name
                            "verification_status": "unverified",  # Default verification status
                            "base_location": default_location,  # Default location
                            "phone": phone_number,  # Truncated phone number
                            "email": user.email,  # Use user's email
                            "address_line1": "Address to be updated",  # Placeholder
                            "city": "City to be updated",  # Placeholder
                            "county": "County to be updated",  # Placeholder
                            "postcode": "Postcode to be updated",  # Placeholder
                        }
                        
                        # Check if ServiceProvider already exists for this user
                        existing_provider = ServiceProvider.objects.filter(user=user).first()
                        if existing_provider:
                            logger.info(f"ServiceProvider already exists for user {user.id}, updating existing record")
                            # Update the existing provider with the new data
                            for key, value in defaults_data.items():
                                setattr(existing_provider, key, value)
                            existing_provider.save()
                            stats["existing_entries"] += 1
                            continue
                        
                        # Log the data being used for debugging
                        logger.info(f"Creating ServiceProvider with data: {defaults_data}")
                        
                        provider = ServiceProvider.objects.create(
                            user=user,
                            **defaults_data
                        )
                        created = True

                        stats["new_entries"] += 1
                        logger.info(
                            f"Created new ServiceProvider entry for user {user.id}"
                        )

                    except Exception as e:
                        # Add more detailed error information
                        error_msg = f"Error processing user {user.id} ({user.email}): {str(e)}"
                        stats["errors"].append(error_msg)
                        logger.error(error_msg)
                        
                        # Log additional debugging info
                        logger.error(f"User data: first_name='{user.first_name}', phone_number='{user.phone_number}'")

                # Check if there were any errors
                if stats["errors"]:
                    return Response(
                        {
                            "status": "partial_success",
                            "message": "Provider sync completed with errors",
                            "statistics": stats,
                        },
                        status=status.HTTP_207_MULTI_STATUS  # 207 Multi-Status
                    )
                else:
                    return Response(
                        {
                            "status": "success",
                            "message": "Provider sync completed successfully",
                            "statistics": stats,
                        }
                    )

        except Exception as e:
            error_msg = f"Error during provider sync: {str(e)}"
            logger.error(error_msg)
            return Response(
                {"status": "error", "message": error_msg},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )
