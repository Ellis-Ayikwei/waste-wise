# apps/accounts/admin.py (or your User app's admin.py)
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.utils.html import format_html
from django.urls import reverse
from .models import User, Address, UserActivity, Document, Availability


class AddressInline(admin.TabularInline):
    """Inline for managing user addresses"""

    model = Address
    fk_name = "address_user"
    extra = 1
    max_num = 3
    fields = [
        "address_line1",
        "address_line2",
        "city",
        "state",
        "postal_code",
        "country",
        "address_type",
    ]
    verbose_name = "Address"
    verbose_name_plural = "Addresses"


class UserActivityInline(admin.TabularInline):
    """Inline for viewing recent user activities"""

    model = UserActivity
    extra = 0
    max_num = 10
    readonly_fields = ["activity_type", "request_link", "created_at"]
    fields = ["activity_type", "request_link", "created_at"]
    ordering = ["-created_at"]
    verbose_name = "Recent Activity"
    verbose_name_plural = "Recent Activities"

    def request_link(self, obj):
        """Create a clickable link to the related request"""
        if obj.request:
            try:
                app_label = obj.request._meta.app_label
                model_name = obj.request._meta.model_name
                url = reverse(
                    f"admin:{app_label}_{model_name}_change", args=[obj.request.pk]
                )
                display_text = (
                    obj.request.tracking_number or f"Request #{obj.request.pk}"
                )
                return format_html(
                    '<a href="{}" target="_blank">{}</a>', url, display_text
                )
            except:
                return obj.request.tracking_number or f"Request #{obj.request.pk}"
        return "-"

    request_link.short_description = "Request"

    def has_add_permission(self, request, obj=None):
        return False

    def has_delete_permission(self, request, obj=None):
        return False


class UserRequestInline(admin.TabularInline):
    """Inline for viewing user requests"""

    from apps.ServiceRequest.models import ServiceRequest

    model = ServiceRequest
    extra = 0
    max_num = 10
    readonly_fields = [
        "request_link",
        "service_type",
        "status",
        "estimated_price",
        "created_at",
    ]
    fields = ["request_link", "service_type", "status", "estimated_price", "created_at"]
    ordering = ["-created_at"]
    verbose_name = "Request"
    verbose_name_plural = "User Requests"

    def request_link(self, obj):
        """Create a clickable link to the request admin page"""
        if obj.pk:
            try:
                app_label = obj._meta.app_label
                model_name = obj._meta.model_name
                url = reverse(f"admin:{app_label}_{model_name}_change", args=[obj.pk])
                display_text = obj.request_id or f"Request #{obj.pk}"
                return format_html(
                    '<a href="{}" target="_blank">{}</a>', url, display_text
                )
            except:
                return obj.request_id or f"Request #{obj.pk}"
        return "New Request"

    request_link.short_description = "Request"

    def has_add_permission(self, request, obj=None):
        return False

    def has_delete_permission(self, request, obj=None):
        return False


@admin.register(User)
class UserAdmin(admin.ModelAdmin):
    """Admin interface for User model"""

    list_display = [
        "email",
        "full_name",
        "user_type",
        "account_status",
        "rating",
        "last_active",
        "date_joined",
    ]
    list_filter = [
        "user_type",
        "account_status",
        "is_active",
        "is_staff",
        "is_superuser",
        "date_joined",
    ]
    search_fields = ["email", "first_name", "last_name", "phone_number"]
    readonly_fields = [
        "id",
        "date_joined",
        "last_login",
        "rating",
        "rating_count",
        "average_rating",
    ]
    date_hierarchy = "date_joined"

    fieldsets = (
        (
            "Basic Information",
            {
                "fields": (
                    "email",
                    "first_name",
                    "last_name",
                    "phone_number",
                    "profile_picture",
                )
            },
        ),
        (
            "Account Status",
            {
                "fields": (
                    "user_type",
                    "account_status",
                    "is_active",
                    "is_staff",
                    "is_superuser",
                )
            },
        ),
        (
            "Ratings & Activity",
            {
                "fields": (
                    "rating",
                    "last_active",
                    "notification_preferences",
                    "device_tokens",
                )
            },
        ),
        (
            "Timestamps",
            {"fields": ("date_joined", "last_login"), "classes": ("collapse",)},
        ),
    )

    def full_name(self, obj):
        """Get user's full name"""
        return obj.get_full_name()

    full_name.short_description = "Full Name"

    def rating_count(self, obj):
        """Get number of ratings received"""
        return obj.get_rating_count()

    rating_count.short_description = "Rating Count"

    def average_rating(self, obj):
        """Get average rating received"""
        return obj.get_average_rating()

    average_rating.short_description = "Average Rating"


@admin.register(Address)
class AddressAdmin(admin.ModelAdmin):
    """Admin interface for Address model"""

    list_display = ["user_email", "address_line1", "city", "postcode", "country"]
    list_filter = ["country", "city"]
    search_fields = [
        "user__email",
        "address_line1",
        "address_line2",
        "city",
        "postcode",
    ]
    readonly_fields = ["id"]

    def user_email(self, obj):
        """Get user's email"""
        return obj.user.email if obj.user else "No User"

    user_email.short_description = "User Email"


@admin.register(UserActivity)
class UserActivityAdmin(admin.ModelAdmin):
    """Admin interface for UserActivity model"""

    list_display = ["user_email", "activity_type", "ip_address", "created_at"]
    list_filter = ["activity_type", "created_at"]
    search_fields = ["user__email", "activity_type", "description", "ip_address"]
    readonly_fields = ["id", "created_at"]
    date_hierarchy = "created_at"

    def user_email(self, obj):
        """Get user's email"""
        return obj.user.email if obj.user else "No User"

    user_email.short_description = "User Email"


@admin.register(Document)
class DocumentAdmin(admin.ModelAdmin):
    """Admin interface for the unified Document model"""

    list_display = [
        "id",
        "document_type",
        "owner_name",
        "status",
        "is_verified",
        "expiry_date",
        "days_until_expiry",
        "created_at",
    ]
    list_filter = [
        "document_type",
        "status",
        "is_verified",
        "is_required",
        "priority",
        "created_at",
        "content_type",
    ]
    search_fields = ["title", "description", "document_number", "verification_notes"]
    readonly_fields = [
        "id",
        "created_at",
        "updated_at",
        "verified_at",
        "has_two_sides",
        "days_until_expiry",
        "is_expired",
        "needs_renewal",
    ]
    date_hierarchy = "created_at"

    fieldsets = (
        (
            "Basic Information",
            {"fields": ("document_type", "title", "description", "document_number")},
        ),
        ("Owner Information", {"fields": ("content_type", "object_id", "owner_name")}),
        (
            "Document Files",
            {"fields": ("document_front", "document_back", "has_two_sides")},
        ),
        (
            "Dates",
            {
                "fields": (
                    "issue_date",
                    "expiry_date",
                    "days_until_expiry",
                    "is_expired",
                    "needs_renewal",
                )
            },
        ),
        (
            "Verification",
            {
                "fields": (
                    "status",
                    "is_verified",
                    "verified_by",
                    "verified_at",
                    "verification_notes",
                )
            },
        ),
        ("Rejection", {"fields": ("rejection_reason",), "classes": ("collapse",)}),
        ("Metadata", {"fields": ("is_required", "priority"), "classes": ("collapse",)}),
        (
            "Timestamps",
            {"fields": ("created_at", "updated_at"), "classes": ("collapse",)},
        ),
    )

    def owner_name(self, obj):
        """Get the name of the document owner"""
        if obj.owner:
            if hasattr(obj.owner, "get_full_name"):
                return obj.owner.get_full_name()
            elif hasattr(obj.owner, "name"):
                return obj.owner.name
            elif hasattr(obj.owner, "business_name"):
                return obj.owner.business_name
            else:
                return str(obj.owner)
        return "Unknown"

    owner_name.short_description = "Owner"

    def days_until_expiry(self, obj):
        """Get days until document expires"""
        return obj.days_until_expiry

    days_until_expiry.short_description = "Days Until Expiry"

    actions = ["verify_documents", "reject_documents", "mark_expired"]

    def verify_documents(self, request, queryset):
        """Verify selected documents"""
        updated = 0
        for document in queryset:
            document.verify(verified_by=request.user)
            updated += 1
        self.message_user(request, f"Successfully verified {updated} document(s).")

    verify_documents.short_description = "Verify selected documents"

    def reject_documents(self, request, queryset):
        """Reject selected documents"""
        updated = queryset.update(status="rejected", is_verified=False)
        self.message_user(request, f"Successfully rejected {updated} document(s).")

    reject_documents.short_description = "Reject selected documents"

    def mark_expired(self, request, queryset):
        """Mark selected documents as expired"""
        updated = 0
        for document in queryset:
            document.mark_expired()
            updated += 1
        self.message_user(
            request, f"Successfully marked {updated} document(s) as expired."
        )

    mark_expired.short_description = "Mark selected documents as expired"


@admin.register(Availability)
class AvailabilityAdmin(admin.ModelAdmin):
    """Admin interface for the unified Availability model"""

    list_display = [
        "id",
        "availability_type",
        "owner_name",
        "day_of_week",
        "start_time",
        "end_time",
        "is_available",
        "is_fully_booked",
        "current_bookings",
        "max_jobs",
    ]
    list_filter = [
        "availability_type",
        "day_of_week",
        "is_available",
        "is_recurring",
        "priority",
        "created_at",
        "content_type",
    ]
    search_fields = ["notes", "owner_name"]
    readonly_fields = [
        "id",
        "created_at",
        "updated_at",
        "duration_hours",
        "is_fully_booked",
        "available_capacity",
    ]
    date_hierarchy = "created_at"

    fieldsets = (
        (
            "Basic Information",
            {
                "fields": (
                    "availability_type",
                    "content_type",
                    "object_id",
                    "owner_name",
                )
            },
        ),
        (
            "Schedule",
            {"fields": ("day_of_week", "start_time", "end_time", "duration_hours")},
        ),
        (
            "Availability Status",
            {"fields": ("is_available", "is_recurring", "specific_date")},
        ),
        (
            "Capacity",
            {
                "fields": (
                    "max_jobs",
                    "current_bookings",
                    "is_fully_booked",
                    "available_capacity",
                )
            },
        ),
        (
            "Restrictions",
            {"fields": ("service_areas", "vehicle_types"), "classes": ("collapse",)},
        ),
        ("Metadata", {"fields": ("notes", "priority"), "classes": ("collapse",)}),
        (
            "Timestamps",
            {"fields": ("created_at", "updated_at"), "classes": ("collapse",)},
        ),
    )

    def owner_name(self, obj):
        """Get the name of the availability owner"""
        if obj.owner:
            if hasattr(obj.owner, "get_full_name"):
                return obj.owner.get_full_name()
            elif hasattr(obj.owner, "name"):
                return obj.owner.name
            elif hasattr(obj.owner, "business_name"):
                return obj.owner.business_name
            else:
                return str(obj.owner)
        return "Unknown"

    owner_name.short_description = "Owner"

    def is_fully_booked(self, obj):
        """Check if this slot is fully booked"""
        return obj.is_fully_booked

    is_fully_booked.short_description = "Fully Booked"
    is_fully_booked.boolean = True

    actions = ["enable_availability", "disable_availability"]

    def enable_availability(self, request, queryset):
        """Enable selected availability slots"""
        updated = queryset.update(is_available=True)
        self.message_user(
            request, f"Successfully enabled {updated} availability slot(s)."
        )

    enable_availability.short_description = "Enable selected availability slots"

    def disable_availability(self, request, queryset):
        """Disable selected availability slots"""
        updated = queryset.update(is_available=False)
        self.message_user(
            request, f"Successfully disabled {updated} availability slot(s)."
        )

    disable_availability.short_description = "Disable selected availability slots"
