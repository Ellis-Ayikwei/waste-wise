from django.contrib import admin
from django.utils.html import format_html
from django.urls import reverse
from django.utils.safestring import mark_safe
import json
from apps.ServiceRequest.models import (
    ServiceRequest,
    ServiceRequestTimelineEvent,
    CitizenReport,
)


@admin.register(ServiceRequest)
class ServiceRequestAdmin(admin.ModelAdmin):
    list_display = (
        "request_id",
        "user_email",
        "service_type",
        "status_badge",
        "priority",
        "final_price_display",
        "service_date_display",
        "assigned_provider_display",
        "created_at",
    )

    list_filter = (
        "status",
        "service_type",
        "priority",
        "payment_method",
        "is_paid",
        "is_instant",
        "is_completed",
        "requires_special_handling",
        "created_at",
        "service_date",
    )

    search_fields = (
        "request_id",
        "user__email",
        "user__first_name",
        "user__last_name",
        "title",
        "description",
        "assigned_provider__business_name",
        "offered_provider__business_name",
    )

    readonly_fields = (
        "request_id",
        "created_at",
        "updated_at",
        "id",
        "locations_display",
        "timeline_events_display",
    )

    ordering = ("-created_at",)
    date_hierarchy = "created_at"
    save_on_top = True

    actions = [
        "mark_as_pending",
        "mark_as_assigned",
        "mark_as_completed",
        "cancel_requests",
        "auto_assign_providers",
    ]

    fieldsets = (
        (
            "Basic Information",
            {
                "fields": (
                    "request_id",
                    "user",
                    "service_type",
                    "title",
                    "description",
                    "status",
                    "priority",
                    "is_instant",
                    "is_completed",
                )
            },
        ),
        (
            "Location Information",
            {
                "fields": (
                    "pickup_location",
                    "pickup_address",
                    "dropoff_location",
                    "dropoff_address",
                    "landmark",
                    "current_location",
                    "locations_display",
                )
            },
        ),
        (
            "Service Details",
            {
                "fields": (
                    "estimated_weight_kg",
                    "actual_weight_kg",
                    "estimated_volume_m3",
                    "actual_volume_m3",
                    "waste_type",
                    "requires_special_handling",
                    "special_instructions",
                    "collection_method",
                )
            },
        ),
        (
            "Scheduling",
            {
                "fields": (
                    "service_date",
                    "service_time_slot",
                    "scheduled_collection_time",
                    "is_recurring",
                    "recurrence_pattern",
                )
            },
        ),
        (
            "Provider Management",
            {
                "fields": (
                    "assigned_provider",
                    "offered_provider",
                    "offer_response",
                    "offer_expires_at",
                    "offer_responded_at",
                    "provider_notes",
                    "assigned_at",
                    "auto_assigned",
                )
            },
        ),
        (
            "Driver Assignment",
            {"fields": ("driver",)},
        ),
        (
            "Timeline Tracking",
            {
                "fields": (
                    "matched_at",
                    "accepted_at",
                    "started_at",
                    "arrived_at",
                    "actual_start_time",
                    "actual_completion_time",
                    "completed_at",
                    "cancelled_at",
                    "timeline_events_display",
                )
            },
        ),
        (
            "Pricing and Payment",
            {
                "fields": (
                    "estimated_price",
                    "final_price",
                    "offered_price",
                    "minimum_bid",
                    "platform_fee",
                    "provider_earnings",
                    "payment_method",
                    "is_paid",
                    "paid_at",
                    "payment_reference",
                )
            },
        ),
        (
            "Offer Terms",
            {
                "fields": (
                    "includes_equipment",
                    "includes_materials",
                    "includes_insurance",
                    "special_conditions",
                )
            },
        ),
        (
            "Distance and Timing",
            {
                "fields": (
                    "distance_km",
                    "distance_to_provider_km",
                    "estimated_duration_minutes",
                    "actual_duration_minutes",
                )
            },
        ),
        (
            "Customer Feedback",
            {
                "fields": (
                    "rating",
                    "review",
                    "reviewed_at",
                )
            },
        ),
        (
            "Service Verification",
            {
                "fields": (
                    "service_proof",
                    "collection_photos",
                    "collection_notes",
                    "collection_verified",
                    "verification_photos",
                )
            },
        ),
        (
            "Environmental Impact",
            {
                "fields": (
                    "co2_emissions_kg",
                    "recycling_rate",
                    "environmental_impact_score",
                )
            },
        ),
        (
            "Additional Information",
            {
                "fields": (
                    "preferred_vehicle_types",
                    "required_qualifications",
                    "notes",
                    "tracking_url",
                    "smart_bin",
                )
            },
        ),
    )

    def user_email(self, obj):
        return obj.user.email if obj.user else "N/A"

    user_email.short_description = "User Email"

    def status_badge(self, obj):
        colors = {
            "draft": "gray",
            "pending": "orange",
            "offered": "blue",
            "accepted": "green",
            "assigned": "purple",
            "en_route": "cyan",
            "arrived": "teal",
            "in_progress": "indigo",
            "completed": "green",
            "cancelled": "red",
            "failed": "red",
        }
        color = colors.get(obj.status, "gray")
        return format_html(
            '<span style="background-color: {}; color: white; padding: 2px 8px; border-radius: 4px;">{}</span>',
            color,
            obj.get_status_display(),
        )

    status_badge.short_description = "Status"

    def final_price_display(self, obj):
        if obj.final_price:
            return f"${obj.final_price}"
        elif obj.estimated_price:
            return f"${obj.estimated_price} (est.)"
        return "N/A"

    final_price_display.short_description = "Price"

    def service_date_display(self, obj):
        return obj.service_date.strftime("%Y-%m-%d") if obj.service_date else "N/A"

    service_date_display.short_description = "Service Date"

    def assigned_provider_display(self, obj):
        if obj.assigned_provider:
            return obj.assigned_provider.business_name
        elif obj.offered_provider:
            return f"{obj.offered_provider.business_name} (offered)"
        return "N/A"

    assigned_provider_display.short_description = "Provider"

    def locations_display(self, obj):
        locations = []
        if obj.pickup_location:
            locations.append(f"Pickup: {obj.pickup_address}")
        if obj.dropoff_location:
            locations.append(f"Dropoff: {obj.dropoff_address}")
        if obj.current_location:
            locations.append("Current: Active location")
        return mark_safe("<br>".join(locations)) if locations else "No locations"

    locations_display.short_description = "Locations"

    def timeline_events_display(self, obj):
        events = obj.timeline_events.all()[:5]  # Show last 5 events
        if events:
            event_list = []
            for event in events:
                event_list.append(
                    f"{event.timestamp.strftime('%Y-%m-%d %H:%M')}: {event.description}"
                )
            return mark_safe("<br>".join(event_list))
        return "No timeline events"

    timeline_events_display.short_description = "Recent Timeline Events"

    def mark_as_pending(self, request, queryset):
        updated = queryset.update(status="pending")
        self.message_user(request, f"{updated} service requests marked as pending.")

    mark_as_pending.short_description = "Mark selected as pending"

    def mark_as_assigned(self, request, queryset):
        updated = queryset.update(status="assigned")
        self.message_user(request, f"{updated} service requests marked as assigned.")

    mark_as_assigned.short_description = "Mark selected as assigned"

    def mark_as_completed(self, request, queryset):
        updated = queryset.update(status="completed", is_completed=True)
        self.message_user(request, f"{updated} service requests marked as completed.")

    mark_as_completed.short_description = "Mark selected as completed"

    def cancel_requests(self, request, queryset):
        updated = queryset.update(status="cancelled")
        self.message_user(request, f"{updated} service requests cancelled.")

    cancel_requests.short_description = "Cancel selected requests"

    def auto_assign_providers(self, request, queryset):
        from apps.ServiceRequest.services import ServiceRequestMatchingService

        assigned_count = 0
        for service_request in queryset.filter(status="pending"):
            if ServiceRequestMatchingService.auto_assign_provider(service_request):
                assigned_count += 1
        self.message_user(
            request, f"{assigned_count} service requests auto-assigned to providers."
        )

    auto_assign_providers.short_description = (
        "Auto-assign providers to selected requests"
    )


@admin.register(ServiceRequestTimelineEvent)
class ServiceRequestTimelineEventAdmin(admin.ModelAdmin):
    list_display = (
        "service_request_id",
        "event_type",
        "description",
        "user_display",
        "timestamp",
        "visibility",
    )

    list_filter = (
        "event_type",
        "visibility",
        "timestamp",
    )

    search_fields = (
        "service_request__request_id",
        "description",
        "user__email",
        "user__first_name",
        "user__last_name",
    )

    readonly_fields = ("timestamp",)

    ordering = ("-timestamp",)

    def service_request_id(self, obj):
        return obj.service_request.request_id if obj.service_request else "N/A"

    service_request_id.short_description = "Service Request ID"

    def user_display(self, obj):
        if obj.user:
            return f"{obj.user.first_name} {obj.user.last_name} ({obj.user.email})"
        return "System"

    user_display.short_description = "User"


@admin.register(CitizenReport)
class CitizenReportAdmin(admin.ModelAdmin):
    list_display = (
        "report_type",
        "title",
        "priority_badge",
        "status_badge",
        "reporter_display",
        "assigned_to_display",
        "created_at",
    )

    list_filter = (
        "report_type",
        "status",
        "priority",
        "requires_follow_up",
        "created_at",
    )

    search_fields = (
        "title",
        "description",
        "reporter_name",
        "reporter_email",
        "address",
        "area",
        "city",
    )

    readonly_fields = (
        "created_at",
        "updated_at",
        "resolved_at",
    )

    ordering = ("-created_at",)
    date_hierarchy = "created_at"

    actions = [
        "mark_as_acknowledged",
        "mark_as_in_progress",
        "mark_as_resolved",
        "assign_to_admin",
    ]

    fieldsets = (
        (
            "Report Information",
            {
                "fields": (
                    "report_type",
                    "title",
                    "description",
                    "priority",
                    "status",
                )
            },
        ),
        (
            "Reporter Information",
            {
                "fields": (
                    "reporter_name",
                    "reporter_phone",
                    "reporter_email",
                    "reporter_user",
                )
            },
        ),
        (
            "Location Information",
            {
                "fields": (
                    "location",
                    "address",
                    "area",
                    "city",
                    "smart_bin",
                )
            },
        ),
        (
            "Media",
            {
                "fields": (
                    "photo_url",
                    "additional_photos",
                )
            },
        ),
        (
            "Assignment and Resolution",
            {
                "fields": (
                    "assigned_to",
                    "resolved_at",
                    "resolution_notes",
                    "resolution_action",
                )
            },
        ),
        (
            "Follow-up",
            {
                "fields": (
                    "requires_follow_up",
                    "follow_up_date",
                    "follow_up_notes",
                )
            },
        ),
    )

    def priority_badge(self, obj):
        colors = {
            "low": "green",
            "medium": "orange",
            "high": "red",
            "critical": "purple",
        }
        color = colors.get(obj.priority, "gray")
        return format_html(
            '<span style="background-color: {}; color: white; padding: 2px 8px; border-radius: 4px;">{}</span>',
            color,
            obj.get_priority_display(),
        )

    priority_badge.short_description = "Priority"

    def status_badge(self, obj):
        colors = {
            "pending": "orange",
            "acknowledged": "blue",
            "in_progress": "purple",
            "resolved": "green",
            "invalid": "gray",
        }
        color = colors.get(obj.status, "gray")
        return format_html(
            '<span style="background-color: {}; color: white; padding: 2px 8px; border-radius: 4px;">{}</span>',
            color,
            obj.get_status_display(),
        )

    status_badge.short_description = "Status"

    def reporter_display(self, obj):
        if obj.reporter_user:
            return f"{obj.reporter_user.first_name} {obj.reporter_user.last_name}"
        return obj.reporter_name or "Anonymous"

    reporter_display.short_description = "Reporter"

    def assigned_to_display(self, obj):
        if obj.assigned_to:
            return f"{obj.assigned_to.first_name} {obj.assigned_to.last_name}"
        return "Unassigned"

    assigned_to_display.short_description = "Assigned To"

    def mark_as_acknowledged(self, request, queryset):
        updated = queryset.update(status="acknowledged")
        self.message_user(request, f"{updated} reports marked as acknowledged.")

    mark_as_acknowledged.short_description = "Mark selected as acknowledged"

    def mark_as_in_progress(self, request, queryset):
        updated = queryset.update(status="in_progress")
        self.message_user(request, f"{updated} reports marked as in progress.")

    mark_as_in_progress.short_description = "Mark selected as in progress"

    def mark_as_resolved(self, request, queryset):
        from django.utils import timezone

        updated = queryset.update(status="resolved", resolved_at=timezone.now())
        self.message_user(request, f"{updated} reports marked as resolved.")

    mark_as_resolved.short_description = "Mark selected as resolved"

    def assign_to_admin(self, request, queryset):
        updated = queryset.update(assigned_to=request.user)
        self.message_user(request, f"{updated} reports assigned to you.")

    assign_to_admin.short_description = "Assign selected to me"
